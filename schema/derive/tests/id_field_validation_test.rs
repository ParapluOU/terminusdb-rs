use terminusdb_schema::{ToTDBSchema, ToTDBInstance, Key, ServerIDFor};
use terminusdb_schema_derive::TerminusDBModel;
use serde::{Deserialize, Serialize};

// Valid: ServerIDFor with lexical key
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "lexical", key_fields = "name", id_field = "id")]
pub struct ValidLexicalWithOption {
    pub id: ServerIDFor<Self>,
    pub name: String,
    pub age: i32,
}

// Valid: String with random key
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "random", id_field = "id")]
pub struct ValidRandomWithString {
    pub id: String,
    pub name: String,
    pub age: i32,
}

// Valid: No id_field specified
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "hash", key_fields = "email")]
pub struct ValidNoIdField {
    pub email: String,
    pub name: String,
}

#[test]
fn test_valid_option_with_lexical_key() {
    assert_eq!(ValidLexicalWithOption::id(), Some("ValidLexicalWithOption".to_string()));
    
    match ValidLexicalWithOption::key() {
        Key::Lexical(fields) => {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0], "name");
        }
        _ => panic!("Expected Lexical key"),
    }
    
    let instance = ValidLexicalWithOption {
        id: ServerIDFor::new(),
        name: "Test".to_string(),
        age: 30,
    };
    
    let tdb_instance = instance.to_instance(None);
    assert_eq!(tdb_instance.id, None); // ID will be generated by TerminusDB
}

#[test]
fn test_valid_string_with_random_key() {
    assert_eq!(ValidRandomWithString::id(), Some("ValidRandomWithString".to_string()));
    assert_eq!(ValidRandomWithString::key(), Key::Random);
    
    let instance = ValidRandomWithString {
        id: "custom-id".to_string(),
        name: "Test".to_string(),
        age: 30,
    };
    
    let tdb_instance = instance.to_instance(None);
    assert_eq!(tdb_instance.id, Some("ValidRandomWithString/custom-id".to_string()));
}

#[test]
fn test_valid_no_id_field() {
    assert_eq!(ValidNoIdField::id(), Some("ValidNoIdField".to_string()));
    
    match ValidNoIdField::key() {
        Key::Hash(fields) => {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0], "email");
        }
        _ => panic!("Expected Hash key"),
    }
}

// The following are now valid (previously would fail compilation):
// The runtime validation in HttpClient will ensure these don't have IDs set for non-Random keys

// Valid: ServerIDFor with lexical key (compile-time validation enforced)
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "lexical", key_fields = "name", id_field = "id")]
pub struct LexicalWithString {
    pub id: ServerIDFor<Self>,
    pub name: String,
}

// Valid: ServerIDFor with hash key
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "hash", key_fields = "email", id_field = "id")]
pub struct HashWithEntityIDFor {
    pub id: terminusdb_schema::ServerIDFor<Self>,
    pub email: String,
}

#[test]
fn test_string_id_with_lexical_key_compiles() {
    // ServerIDFor ensures compile-time validation
    let instance = LexicalWithString {
        id: ServerIDFor::new(),
        name: "Test".to_string(),
    };
    
    // The to_instance method will handle the ServerIDFor properly
    let tdb_instance = instance.to_instance(None);
    // For ServerIDFor, the ID is None until the server assigns it
    assert_eq!(tdb_instance.id, None);
}