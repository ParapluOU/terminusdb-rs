use terminusdb_schema::{ToTDBSchema, ToTDBInstance, Key};
use terminusdb_schema_derive::TerminusDBModel;
use serde::{Deserialize, Serialize};

// Valid: Option<String> with lexical key
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "lexical", key_fields = "name", id_field = "id")]
pub struct ValidLexicalWithOption {
    pub id: Option<String>,
    pub name: String,
    pub age: i32,
}

// Valid: String with random key
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "random", id_field = "id")]
pub struct ValidRandomWithString {
    pub id: String,
    pub name: String,
    pub age: i32,
}

// Valid: No id_field specified
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "hash", key_fields = "email")]
pub struct ValidNoIdField {
    pub email: String,
    pub name: String,
}

#[test]
fn test_valid_option_with_lexical_key() {
    assert_eq!(ValidLexicalWithOption::id(), Some("ValidLexicalWithOption".to_string()));
    
    match ValidLexicalWithOption::key() {
        Key::Lexical(fields) => {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0], "name");
        }
        _ => panic!("Expected Lexical key"),
    }
    
    let instance = ValidLexicalWithOption {
        id: None,
        name: "Test".to_string(),
        age: 30,
    };
    
    let tdb_instance = instance.to_instance(None);
    assert_eq!(tdb_instance.id, None); // ID will be generated by TerminusDB
}

#[test]
fn test_valid_string_with_random_key() {
    assert_eq!(ValidRandomWithString::id(), Some("ValidRandomWithString".to_string()));
    assert_eq!(ValidRandomWithString::key(), Key::Random);
    
    let instance = ValidRandomWithString {
        id: "custom-id".to_string(),
        name: "Test".to_string(),
        age: 30,
    };
    
    let tdb_instance = instance.to_instance(None);
    assert_eq!(tdb_instance.id, Some("ValidRandomWithString/custom-id".to_string()));
}

#[test]
fn test_valid_no_id_field() {
    assert_eq!(ValidNoIdField::id(), Some("ValidNoIdField".to_string()));
    
    match ValidNoIdField::key() {
        Key::Hash(fields) => {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0], "email");
        }
        _ => panic!("Expected Hash key"),
    }
}

// The following are now valid (previously would fail compilation):
// The runtime validation in HttpClient will ensure these don't have IDs set for non-Random keys

// Valid: String with lexical key (runtime validation enforced)
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "lexical", key_fields = "name", id_field = "id")]
pub struct LexicalWithString {
    pub id: String, // Now allowed, but runtime will panic if ID is set
    pub name: String,
}

// Valid: EntityIDFor with hash key
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "hash", key_fields = "email", id_field = "id")]
pub struct HashWithEntityIDFor {
    pub id: terminusdb_schema::EntityIDFor<Self>,
    pub email: String,
}

#[test]
fn test_string_id_with_lexical_key_compiles() {
    // This now compiles, but runtime validation will prevent setting an ID
    let instance = LexicalWithString {
        id: String::new(), // Empty string for unset ID
        name: "Test".to_string(),
    };
    
    // The to_instance method will extract the ID properly
    let tdb_instance = instance.to_instance(None);
    // For a String field with empty value, the schema class prefix is added
    assert_eq!(tdb_instance.id, Some("LexicalWithString/".to_string()));
}