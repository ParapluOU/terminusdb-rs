use terminusdb_schema::{ToTDBSchema, ToTDBInstance, Key};
use terminusdb_schema_derive::TerminusDBModel;
use serde::{Deserialize, Serialize};

// Valid: Option<String> with lexical key
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "lexical", key_fields = "name", id_field = "id")]
pub struct ValidLexicalWithOption {
    pub id: Option<String>,
    pub name: String,
    pub age: i32,
}

// Valid: String with random key
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "random", id_field = "id")]
pub struct ValidRandomWithString {
    pub id: String,
    pub name: String,
    pub age: i32,
}

// Valid: No id_field specified
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "hash", key_fields = "email")]
pub struct ValidNoIdField {
    pub email: String,
    pub name: String,
}

#[test]
fn test_valid_option_with_lexical_key() {
    assert_eq!(ValidLexicalWithOption::id(), Some("ValidLexicalWithOption".to_string()));
    
    match ValidLexicalWithOption::key() {
        Key::Lexical(fields) => {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0], "name");
        }
        _ => panic!("Expected Lexical key"),
    }
    
    let instance = ValidLexicalWithOption {
        id: None,
        name: "Test".to_string(),
        age: 30,
    };
    
    let tdb_instance = instance.to_instance(None);
    assert_eq!(tdb_instance.id, None); // ID will be generated by TerminusDB
}

#[test]
fn test_valid_string_with_random_key() {
    assert_eq!(ValidRandomWithString::id(), Some("ValidRandomWithString".to_string()));
    assert_eq!(ValidRandomWithString::key(), Key::Random);
    
    let instance = ValidRandomWithString {
        id: "custom-id".to_string(),
        name: "Test".to_string(),
        age: 30,
    };
    
    let tdb_instance = instance.to_instance(None);
    assert_eq!(tdb_instance.id, Some("ValidRandomWithString/custom-id".to_string()));
}

#[test]
fn test_valid_no_id_field() {
    assert_eq!(ValidNoIdField::id(), Some("ValidNoIdField".to_string()));
    
    match ValidNoIdField::key() {
        Key::Hash(fields) => {
            assert_eq!(fields.len(), 1);
            assert_eq!(fields[0], "email");
        }
        _ => panic!("Expected Hash key"),
    }
}

// The following would fail compilation if uncommented:
/*
// Invalid: String with lexical key
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "lexical", key_fields = "name", id_field = "id")]
pub struct InvalidLexicalWithString {
    pub id: String, // This should be Option<String>
    pub name: String,
}

// Invalid: String with hash key
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "hash", key_fields = "email", id_field = "id")]
pub struct InvalidHashWithString {
    pub id: String, // This should be Option<String>
    pub email: String,
}

// Invalid: String with value_hash key
#[derive(Debug, Clone, Deserialize, Serialize, Eq, PartialEq, TerminusDBModel)]
#[tdb(key = "value_hash", id_field = "id")]
pub struct InvalidValueHashWithString {
    pub id: String, // This should be Option<String>
    pub data: String,
}
*/