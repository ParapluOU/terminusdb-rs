//! Integration tests for ModelExt::query() with relation filters.
//!
//! Tests the complete flow: Schema → GraphQL Filter → Query Execution

use serde::{Deserialize, Serialize};
use terminusdb_client::DocumentInsertArgs;
use terminusdb_orm::prelude::*;
use terminusdb_schema::ToTDBInstance;
use terminusdb_schema_derive::TerminusDBModel;
use terminusdb_test::test as db_test;

// Required for derive macro
use terminusdb_schema as terminusdb_schema;

// Test models with relations

#[derive(Debug, Clone, Default, TerminusDBModel)]
#[tdb(key = "Lexical")]
pub struct TestProject {
    pub name: String,
    pub description: Option<String>,
}

#[derive(Debug, Clone, TerminusDBModel)]
#[tdb(key = "Lexical")]
pub struct TestTicket {
    pub title: String,
    pub project: EntityIDFor<TestProject>,
    pub parent: Option<EntityIDFor<TestTicket>>,
}

// Manually define filter types (normally generated by build.rs)

#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct StringFilter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eq: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ne: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub regex: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub startsWith: Option<String>,
}

#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct TestProjectFilter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<StringFilter>,
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "_and", skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<Box<TestProjectFilter>>>,
    #[serde(rename = "_or", skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<Box<TestProjectFilter>>>,
}

#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct TestTicketFilter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<StringFilter>,
    // Note: TerminusDB treats EntityIDFor<T> relations as string IDs, not nested filters
    #[serde(skip_serializing_if = "Option::is_none")]
    pub project: Option<StringFilter>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<StringFilter>,
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "_and", skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<Box<TestTicketFilter>>>,
    #[serde(rename = "_or", skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<Box<TestTicketFilter>>>,
}

// Simple stub ordering type for tests
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct StubOrdering;

// Implement TdbGQLFilter/TdbGQLOrdering to link filters to their models
impl TdbGQLFilter<TestProject> for TestProjectFilter {}
impl TdbGQLOrdering<TestProject> for StubOrdering {}

impl TdbGQLFilter<TestTicket> for TestTicketFilter {}
impl TdbGQLOrdering<TestTicket> for StubOrdering {}

/// Test that filter query builds correct GraphQL query string
#[test]
fn test_filter_query_builds_correct_graphql() {
    let filter = TestTicketFilter {
        title: Some(StringFilter {
            eq: Some("Bug Fix".to_string()),
            ..Default::default()
        }),
        // TerminusDB treats relations as string IDs
        project: Some(StringFilter {
            eq: Some("TestProject/main-project".to_string()),
            ..Default::default()
        }),
        ..Default::default()
    };

    // Test that the filter serializes correctly for GraphQL
    let json = serde_json::to_string(&filter).unwrap();
    println!("Filter JSON: {}", json);

    // Verify the filter serializes correctly for GraphQL
    assert!(json.contains("\"title\""));
    assert!(json.contains("\"eq\":\"Bug Fix\""));
    assert!(json.contains("\"project\""));
    assert!(json.contains("TestProject/main-project"));
}

/// Integration test: Execute filter query against real database
#[db_test(db = "filter_query_exec")]
async fn test_filter_query_execution(client: _, spec: _) -> anyhow::Result<()> {
    // Insert schemas
    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_entity_schema::<TestProject>(args).await?;

    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_entity_schema::<TestTicket>(args).await?;

    // Insert test data
    let project1 = TestProject {
        name: "Project Alpha".to_string(),
        description: Some("First project".to_string()),
    };
    let project2 = TestProject {
        name: "Project Beta".to_string(),
        description: None,
    };

    let args = DocumentInsertArgs::from(spec.clone());
    let result1 = client.insert_instance(&project1, args.clone()).await?;
    let result2 = client.insert_instance(&project2, args.clone()).await?;

    let project1_id = result1.root_id.clone();
    let project2_id = result2.root_id.clone();

    // Insert tickets
    let ticket1 = TestTicket {
        title: "Fix bug in Alpha".to_string(),
        project: EntityIDFor::new_unchecked(&project1_id)?,
        parent: None,
    };
    let ticket2 = TestTicket {
        title: "Add feature to Alpha".to_string(),
        project: EntityIDFor::new_unchecked(&project1_id)?,
        parent: None,
    };
    let ticket3 = TestTicket {
        title: "Fix bug in Beta".to_string(),
        project: EntityIDFor::new_unchecked(&project2_id)?,
        parent: None,
    };

    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_instance(&ticket1, args.clone()).await?;
    client.insert_instance(&ticket2, args.clone()).await?;
    client.insert_instance(&ticket3, args.clone()).await?;

    // Test 1: Filter tickets by title
    let filter = TestTicketFilter {
        title: Some(StringFilter {
            startsWith: Some("Fix".to_string()),
            ..Default::default()
        }),
        ..Default::default()
    };

    let results = TestTicket::query(filter)
        .with_client(&client)
        .execute(&spec)
        .await?;

    println!("Tickets starting with 'Fix': {:?}", results.len());
    assert_eq!(results.len(), 2, "Should find 2 tickets starting with 'Fix'");

    // Test 2: Filter tickets by project ID (TerminusDB treats relations as string IDs)
    // Note: TerminusDB stores relation IDs in short form (e.g., "TestProject/abc123")
    // not the full IRI form (e.g., "terminusdb:///data/TestProject/abc123")
    let short_id = project1_id
        .strip_prefix("terminusdb:///data/")
        .unwrap_or(&project1_id);

    let filter_by_project = TestTicketFilter {
        project: Some(StringFilter {
            eq: Some(short_id.to_string()),
            ..Default::default()
        }),
        ..Default::default()
    };

    let alpha_tickets = TestTicket::query(filter_by_project)
        .with_client(&client)
        .execute(&spec)
        .await?;

    println!("Tickets in Project Alpha: {:?}", alpha_tickets.len());
    assert_eq!(
        alpha_tickets.len(),
        2,
        "Should find 2 tickets in Project Alpha"
    );

    // Test 3: Combined filter - title AND project ID (using short form)
    let combined_filter = TestTicketFilter {
        title: Some(StringFilter {
            startsWith: Some("Fix".to_string()),
            ..Default::default()
        }),
        project: Some(StringFilter {
            eq: Some(short_id.to_string()),
            ..Default::default()
        }),
        ..Default::default()
    };

    let filtered = TestTicket::query(combined_filter)
        .with_client(&client)
        .execute(&spec)
        .await?;

    println!("'Fix' tickets in Alpha: {:?}", filtered.len());
    assert_eq!(
        filtered.len(),
        1,
        "Should find 1 ticket starting with 'Fix' in Project Alpha"
    );

    Ok(())
}

/// Test filter query with empty results
#[db_test(db = "filter_query_empty")]
async fn test_filter_query_no_matches(client: _, spec: _) -> anyhow::Result<()> {
    // Insert schema
    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_entity_schema::<TestProject>(args).await?;

    // Insert one project
    let project = TestProject {
        name: "Only Project".to_string(),
        description: None,
    };
    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_instance(&project, args).await?;

    // Query for non-existent project
    let filter = TestProjectFilter {
        name: Some(StringFilter {
            eq: Some("Does Not Exist".to_string()),
            ..Default::default()
        }),
        ..Default::default()
    };

    let results = TestProject::query(filter)
        .with_client(&client)
        .execute(&spec)
        .await?;

    assert!(results.is_empty(), "Should return empty for no matches");
    Ok(())
}

/// Test filter().all() without any filter
#[db_test(db = "filter_query_all")]
async fn test_filter_query_all(client: _, spec: _) -> anyhow::Result<()> {
    // Insert schema
    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_entity_schema::<TestProject>(args).await?;

    // Insert multiple projects
    let args = DocumentInsertArgs::from(spec.clone());

    for i in 1..=5 {
        let project = TestProject {
            name: format!("Project {}", i),
            description: None,
        };
        client.insert_instance(&project, args.clone()).await?;
    }

    // Query all with limit
    let results = TestProject::query_all()
        .with_client(&client)
        .limit(3)
        .execute(&spec)
        .await?;

    assert_eq!(results.len(), 3, "Should return 3 projects with limit");

    // Query all without limit
    let all_results = TestProject::query_all()
        .with_client(&client)
        .execute(&spec)
        .await?;

    assert_eq!(all_results.len(), 5, "Should return all 5 projects");

    Ok(())
}

// ============================================================================
// TdbLazy relation filter test - nested filtering on relations
// ============================================================================

use terminusdb_schema::TdbLazy;

#[derive(Debug, Clone, Default, TerminusDBModel)]
#[tdb(key = "Lexical")]
pub struct Author {
    pub name: String,
}

#[derive(Debug, Clone, TerminusDBModel)]
#[tdb(key = "Lexical")]
pub struct Article {
    pub title: String,
    /// TdbLazy creates actual document link - enables nested filters
    pub author: TdbLazy<Author>,
}

// Filter types for TdbLazy models - note author uses nested AuthorFilter!
#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct AuthorFilter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<StringFilter>,
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct ArticleFilter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<StringFilter>,
    /// TdbLazy relation gets nested filter type!
    #[serde(skip_serializing_if = "Option::is_none")]
    pub author: Option<AuthorFilter>,
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

impl TdbGQLFilter<Author> for AuthorFilter {}
impl TdbGQLOrdering<Author> for StubOrdering {}

impl TdbGQLFilter<Article> for ArticleFilter {}
impl TdbGQLOrdering<Article> for StubOrdering {}

/// Test that TdbLazy relations get nested filter types (not StringFilter)
#[db_test(db = "tdblazy_filter_schema")]
async fn test_tdblazy_nested_filter_schema(client: _, spec: _) -> anyhow::Result<()> {
    use terminusdb_client::graphql::GraphQLRequest;

    // Insert schemas
    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_entity_schema::<Author>(args).await?;

    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_entity_schema::<Article>(args).await?;

    // Introspect the filter type
    let introspection = r#"
        query {
            __type(name: "Article_Filter") {
                name
                inputFields {
                    name
                    type {
                        name
                        kind
                    }
                }
            }
        }
    "#;
    let request = GraphQLRequest::new(introspection);
    let response = client
        .execute_graphql::<serde_json::Value>(&spec.db, Some("main"), request, None)
        .await?;

    // Check that author field has Author_Filter type (not StringFilter)
    let data = response.data.unwrap();
    let fields = data["__type"]["inputFields"].as_array().unwrap();

    let author_field = fields.iter().find(|f| f["name"] == "author").unwrap();
    let author_type = author_field["type"]["name"].as_str().unwrap();

    // TdbLazy should create nested filter, not StringFilter
    assert_eq!(
        author_type, "Author_Filter",
        "TdbLazy relation should have nested Author_Filter, not StringFilter"
    );

    Ok(())
}

/// Test that nested filtering actually WORKS - filter articles by author.name
#[db_test(db = "tdblazy_filter_exec")]
async fn test_tdblazy_nested_filter_execution(client: _, spec: _) -> anyhow::Result<()> {
    // Insert schemas
    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_entity_schema::<Author>(args).await?;

    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_entity_schema::<Article>(args).await?;

    // Create authors
    let alice = Author {
        name: "Alice Smith".to_string(),
    };
    let bob = Author {
        name: "Bob Jones".to_string(),
    };

    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_instance(&alice, args.clone()).await?;
    client.insert_instance(&bob, args.clone()).await?;

    // Create articles - 2 by Alice, 1 by Bob
    let article1 = Article {
        title: "Rust for Beginners".to_string(),
        author: TdbLazy::new_data(alice.clone())?,
    };
    let article2 = Article {
        title: "Advanced Rust Patterns".to_string(),
        author: TdbLazy::new_data(alice.clone())?,
    };
    let article3 = Article {
        title: "Python Basics".to_string(),
        author: TdbLazy::new_data(bob.clone())?,
    };

    client.insert_instance(&article1, args.clone()).await?;
    client.insert_instance(&article2, args.clone()).await?;
    client.insert_instance(&article3, args.clone()).await?;

    // Test 1: Filter articles by author name using NESTED filter
    let filter_by_alice = ArticleFilter {
        author: Some(AuthorFilter {
            name: Some(StringFilter {
                eq: Some("Alice Smith".to_string()),
                ..Default::default()
            }),
            ..Default::default()
        }),
        ..Default::default()
    };

    let alice_articles = Article::query(filter_by_alice)
        .with_client(&client)
        .execute(&spec)
        .await?;

    println!("Articles by Alice: {}", alice_articles.len());
    assert_eq!(
        alice_articles.len(),
        2,
        "Should find 2 articles by Alice Smith"
    );

    // Test 2: Combined filter - title contains "Rust" AND author is Alice
    let rust_by_alice = ArticleFilter {
        title: Some(StringFilter {
            regex: Some("Rust".to_string()),
            ..Default::default()
        }),
        author: Some(AuthorFilter {
            name: Some(StringFilter {
                eq: Some("Alice Smith".to_string()),
                ..Default::default()
            }),
            ..Default::default()
        }),
        ..Default::default()
    };

    let rust_articles = Article::query(rust_by_alice)
        .with_client(&client)
        .execute(&spec)
        .await?;

    println!("Rust articles by Alice: {}", rust_articles.len());
    assert_eq!(
        rust_articles.len(),
        2,
        "Should find 2 Rust articles by Alice"
    );

    // Test 3: Filter by Bob
    let filter_by_bob = ArticleFilter {
        author: Some(AuthorFilter {
            name: Some(StringFilter {
                eq: Some("Bob Jones".to_string()),
                ..Default::default()
            }),
            ..Default::default()
        }),
        ..Default::default()
    };

    let bob_articles = Article::query(filter_by_bob)
        .with_client(&client)
        .execute(&spec)
        .await?;

    println!("Articles by Bob: {}", bob_articles.len());
    assert_eq!(bob_articles.len(), 1, "Should find 1 article by Bob Jones");

    Ok(())
}

// ============================================================================
// Test _not filter for absent/null optional fields
// ============================================================================

#[derive(Debug, Clone, Default, TerminusDBModel)]
#[tdb(key = "Lexical")]
pub struct Task {
    pub title: String,
    /// Optional assignee - can be None (absent)
    pub assignee: Option<TdbLazy<Author>>,
}

#[derive(Default, Clone, Debug, Serialize, Deserialize)]
pub struct TaskFilter {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<StringFilter>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assignee: Option<AuthorFilter>,
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "_not", skip_serializing_if = "Option::is_none")]
    pub not: Option<Box<TaskFilter>>,
    #[serde(rename = "_and", skip_serializing_if = "Option::is_none")]
    pub and: Option<Vec<Box<TaskFilter>>>,
    #[serde(rename = "_or", skip_serializing_if = "Option::is_none")]
    pub or: Option<Vec<Box<TaskFilter>>>,
}

impl TdbGQLFilter<Task> for TaskFilter {}
impl TdbGQLOrdering<Task> for StubOrdering {}

/// Test that _not filter can find records where an optional relation is absent/null
#[db_test(db = "not_filter_null_check")]
async fn test_not_filter_for_absent_field(client: _, spec: _) -> anyhow::Result<()> {
    // Insert schemas
    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_entity_schema::<Author>(args).await?;

    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_entity_schema::<Task>(args).await?;

    // Create an assignee
    let alice = Author {
        name: "Alice".to_string(),
    };
    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_instance(&alice, args.clone()).await?;

    // Create tasks - some with assignee, some without
    let task1 = Task {
        title: "Task with assignee".to_string(),
        assignee: Some(TdbLazy::new_data(alice.clone())?),
    };
    let task2 = Task {
        title: "Unassigned task 1".to_string(),
        assignee: None,
    };
    let task3 = Task {
        title: "Unassigned task 2".to_string(),
        assignee: None,
    };
    let task4 = Task {
        title: "Another assigned task".to_string(),
        assignee: Some(TdbLazy::new_data(alice.clone())?),
    };

    let args = DocumentInsertArgs::from(spec.clone());
    client.insert_instance(&task1, args.clone()).await?;
    client.insert_instance(&task2, args.clone()).await?;
    client.insert_instance(&task3, args.clone()).await?;
    client.insert_instance(&task4, args.clone()).await?;

    // Test 1: Filter for tasks WITH an assignee (any assignee)
    let filter_has_assignee = TaskFilter {
        assignee: Some(AuthorFilter::default()),
        ..Default::default()
    };

    let assigned_tasks = Task::query(filter_has_assignee)
        .with_client(&client)
        .execute(&spec)
        .await?;

    println!("Tasks with assignee: {}", assigned_tasks.len());
    assert_eq!(
        assigned_tasks.len(),
        2,
        "Should find 2 tasks with assignee"
    );

    // Test 2: Filter for tasks WITHOUT an assignee using _not
    // The pattern: _not(assignee: any) gives us tasks where assignee is absent
    let filter_no_assignee = TaskFilter {
        not: Some(Box::new(TaskFilter {
            assignee: Some(AuthorFilter::default()),
            ..Default::default()
        })),
        ..Default::default()
    };

    let unassigned_tasks = Task::query(filter_no_assignee)
        .with_client(&client)
        .execute(&spec)
        .await?;

    println!("Tasks without assignee: {}", unassigned_tasks.len());
    assert_eq!(
        unassigned_tasks.len(),
        2,
        "Should find 2 tasks without assignee using _not filter"
    );

    // Verify the unassigned tasks have the expected titles
    let unassigned_titles: Vec<_> = unassigned_tasks.iter().map(|t| &t.title).collect();
    assert!(
        unassigned_titles.contains(&&"Unassigned task 1".to_string()),
        "Should contain 'Unassigned task 1'"
    );
    assert!(
        unassigned_titles.contains(&&"Unassigned task 2".to_string()),
        "Should contain 'Unassigned task 2'"
    );

    Ok(())
}
